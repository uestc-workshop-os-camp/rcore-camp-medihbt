# Ch6 -- 文件系统

## 实现了什么

1. 为 EasyFS 添加 Inode 引用计数机制, 现在文件系统支持硬链接
2. 实现了 `linkat()`, `unlinkat()` 和 `fstat()` 系统调用

## 反馈

1. 每次从旧分支切换到新分支都要重新实现一遍 `copy_to_user()` 之类的工具和 `mmap()` 之类的系统调用, 重复工作
2. sys_write() 每次写完都要刷新一遍磁盘缓冲区, 而我的 qemu-system-riscv64 + QEMU/KVM 两层嵌套虚拟机零散读写延迟巨大, 因此很经常超时。在 ch6 里, 30s 不够测完所有的项目, 经常要改 Makefile 到 60s 以上.

## 问答题

1. 文件系统的功能是什么？

实现文件定义、把线性的块设备抽象为文件集合；提供文件操作接口，部分文件系统可以提供其他内核对象的操作接口

2. 目前的文件系统只有单级目录，假设想要支持多级文件目录，请描述你设想的实现方式，描述合理即可。

要支持多级文件目录，需要在 VFS 层与文件系统层都做一些修改

VFS 层要做的修改有：抽象出一个路径接口，使其支持父目录、子目录项等接口函数; 添加一个路径缓存层，把最近使用的路径对象以内存结点树的形式组织起来

EasyFS 文件系统层要做的修改是: 让任意 inode 都支持目录/文件两种模式.

3. 软链接和硬链接是干什么的？有什么区别？当删除一个软链接或硬链接时分别会发生什么？

两种链接的作用都是为了让一个文件有不同的名字/路径.

软链接是一个存储路径的文件，但操作系统会把这个软链接当成它指向的路径.

硬链接就是目录中直接指向 inode 的目录项. 一个 inode 至少有一个硬链接.

4. 在有了多级目录之后，我们就也可以为一个目录增加硬链接了。在这种情况下，文件树中是否可能出现环路(软硬链接都可以，鼓励多尝试)？你认为应该如何解决？请在你喜欢的系统上实现一个环路，描述你的实现方式以及系统提示、实际测试结果。

当一个下级“目录”是上几级目录的链接(软硬链接均可)时, 文件系统中就会出现环路。软链接可以看成一个弱引用, 因此环路不会对文件系统产生破坏性影响。但是，硬链接环路会导致目录循环遍历进入无限循环，目录的删除操作也会变得极其复杂(从低消耗的引用计数变为又慢又复杂的扫描-清除)来防止块设备存储空间泄露.

解决方案有限制文件路径层数、遍历时记录已经访问的 inode、禁止目录作为硬链接等。

由于 Linux 禁止目录作为硬链接，在不考虑 bind mount 的情况下不会形成具有破坏性的硬链接环路，因此这里做一个软链接回路:

```bash
mkdir -p ~/path/to/test && cd ~/path/to/test
ln -s ../../ backlink
```

环路为: `path -> to -> test -> (backlink ...> path)`, 是软链接环路.

使用 bind mount 可以做出一个类似硬链接环路的环路:

```bash
sudo su
mkdir -p ~/path/to/test && cd ~/path/to/
mount -o bind ../ test
```

环路为 `path -> to -> test(= path)`.

5. 目录是一类特殊的文件，存放的是什么内容？用户可以自己修改目录内容吗？

目录是目录项表, 存放目录名称与对应的目录项/硬链接之间的对应关系. 用户只能以操作目录项表的方式读写目录，不能当成普通文件读写。

6. 在实际操作系统中，如Linux，为什么会存在大量的文件系统类型？

生产实践中人们对文件系统读写性能、大小文件支持程度、数据安全性、文件系统特性、实现成本高低、适配的操作系统类型等的要求各不相同，而功能全、速度快、文件多、数据安全、容易实现、适配所有操作系统这几点不可能同时做到，因此诞生了诸如 NTFS, ext2/3/4, BtrFS, XFS, FAT/FAT32/exFAT 等文件系统.

7. 可以把文件控制块放到目录项中吗？这样做有什么优缺点？

可以，FAT32 几乎就是这么做的. 这么做可以极大简化实现, 对小目录还可以减少一次读开销; 但不支持一个 inode 带多个硬链接了, 而且会极大增加大目录的空间, 降低大目录性能.

8. 为什么要同时维护进程的打开文件表和操作系统的打开文件表？这两个打开文件表有什么区别和联系？

每个进程单独维护一个打开的文件表是为了记录进程自己打开文件的权限等信息，而各进程之间的打开方式等信息不尽相同，需要隔离.

操作系统自己维护一个全局的已打开文件表是为了考虑不同进程之间的同步问题。它的主要目的是跟踪文件的打开状态，确保多个进程之间对同一文件的访问能够正确同步，同时支持文件系统的整体管理功能，如文件共享、权限控制等。

区别：维护的目的不同、文件表结构的不同

联系：

- 进程打开的文件表通常会带一些全局文件表的信息, 确保进程能访问到正确的文件数据，同时支持文件共享和同步机制。
- 同步和权限控制：通过操作系统的打开文件表，系统可以跟踪每个文件的打开状态和引用计数，从而实现对文件访问的同步控制和权限管理。当多个进程试图访问同一文件时，系统可以确保它们之间的操作不会相互干扰，并根据文件的权限设置来决定每个进程是否能够访问该文件。

9. 文件分配的三种方式是如何组织文件数据块的？各有什么特征（存储、文件读写、可靠性）？

三种方式——连续分配、链接分配、索引分配:

- 连续分配:
  - 组织方式: 为文件内容分配一组连续的磁盘块.
  - 存储: 文件内容连续存储在块设备的某一段区间上.
  - 文件读写: 可以直接通过 "起始地址+偏移量" 的方式读写内容, 顺序读写很快.
  - 可靠性: 空间管理简单，数据块损坏时不影响其他数据块; 很容易出现碎片, 很容易出现空间明明足够但就是不能存储文件的情况.
- 链接分配:
  - 组织方式: 为文件内容分配不连续的磁盘块, 并通过前驱/后继关系把这些块连接起来.
  - 存储: 数据块分散存储、通过指针/前后向索引连接.
  - 文件读写: 要读写文件特定位置的内容, 需要从头开始通过链表逐个找到需要的数据块. 因此顺序读写比较快、文件附加内容比较快、随机读写(尤其是区间变化很大的)很慢
  - 可靠性: 一个数据块损坏会把后面所有的数据都丢掉，可靠性不好.
- 索引分配:
  - 组织方式: 为文件内容分配不连续的磁盘块, 并通过索引表存储这些块的索引关系.
  - 存储：分散存储，通过索引表访问.
  - 文件读写: 索引分配支持直接访问和顺序访问。直接访问时，可以根据索引表直接找到相应的数据块；顺序访问时，可以按照索引表的顺序依次读取数据块。索引分配的文件读写速度较快，但索引表本身会占用一定的磁盘空间。
  - 可靠性: 数据块损坏不影响其他内容, 多级索引块的一级损坏时会丢失下面所有次级索引的数据, 索引表损坏时整个文件丢失.

10. 如果一个程序打开了一个文件，写入了一些数据，但是没有及时关闭，可能会有什么后果？如果打开文件后，又进一步发出了读文件的系统调用，操作系统中各个组件是如何相互协作完成整个读文件的系统调用的？

后果：占用文件描述符等资源，造成资源泄露; 一旦进程或者操作系统崩溃, 内存缓存损坏, 文件面临损坏风险.

读文件系统调用实现过程:

- 系统调用层转发读调用到文件系统接口层，进一步转发到文件系统驱动
- 文件系统驱动根据内部实现计算出需要读取的数据块, 并请求块设备层读取这些数据块
- 块设备层转发读取调用到块设备驱动(磁盘驱动)
- 块设备驱动读取块数据，逐层返回文件系统驱动
- 文件系统驱动解析块数据并组织成文件内容，逐层返回并传递至用户态

11. 文件系统是一个操作系统必要的组件吗？是否可以将文件系统放到用户态？这样做有什么好处？操作系统需要提供哪些基本支持？

不是, 一些 RTOS 没有动态存储、读写数据的要求, 不需要文件系统.

文件系统可以放到用户态实现, 例如 Linux FUSE 框架及 GVFS 等文件系统. 这么做不用担心许可证等法律问题、不用与频繁变化的内核接口保持同步，还可以使用用户态下丰富的中间件与开发工具.

操作系统要向用户态文件系统驱动程序提供文件系统的注册/注销接口，并能把来自其他进程的文件读写转发到驱动.
